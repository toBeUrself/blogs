> http 是应用层非常常见的协议，是超文本传输协议的简称，其传输的内容都是明文的。在这个混乱的世界，明文传输信息想想就觉得很可怕，传输的信息很容易被劫持、篡改。https 就是为了解决这个问题而诞生的。

### 一层层揭开 HTTPS 神秘面纱

1. 第一层  安全传输数据

****

假如我们要实现一个功能：

+ 一个用户A给一个用户B发消息，但是要保证这个消息的内容只能被A和B知道，而其他任何人都不能破解和篡改消息的内容。

这就需要用到加密，加密算法分为两类： **对称加密和非对称加密**,这里可以使用对称加密，原因如下：

+ 对称加密速度快，加密时CPU资源消耗少
+ 非对称加密对待加密的数据的长度有严格的要求，不能太长，但是实际中消息可能会很长，因此非对称加密就满足不了了。

既然消息是加密传输的，那就需要把秘钥告诉对方，对方才能解密内容。这就是导致了整个 HTTPS 通信过程比较复杂的原因。如果A或者B直接把他们之间用于解密的秘钥通过互联网传输给对方，那一旦秘钥被第三者劫持，第三者就能正确解密A，B之间的通信数据。

2. 第二层  安全传输秘钥

****

通过第一层的描述，第二层需要解决的问题就是：**安全的传输A，B之间用于解密数据的秘钥**。

因为如果传输过程中秘钥被第三者劫持，就能解密通信数据，所以，秘钥必须得加密，就算第三者劫持到加密过的秘钥，第三者也不能解密，得到真正的秘钥。

这里有一个问题，要用什么方式加密秘钥？如果使用对称加密，那这个对称加密的秘钥又怎么安全的告诉对方呢？这就会陷入死循环，所以，一定不能用对称加密。需要使用非对称加密。

考虑如下方式：

1. 客户端： 我要发起HTTPS请求，麻烦给我一个非对称加密的公钥；
2. 服务器： (生成一对非对称加密的密钥对，然后把公钥发给客户端)，接着，这是公钥；
3. 客户端：（收到公钥，生成一个随机数，作为上图中那一把密钥，用刚才收到的公钥加密这个密钥，然后发给服务器）这是我刚生成的加密过的密钥；
4. 服务器：（收到加密后的密钥，用本地的第一步自己生成的非对称加密的私钥解密，得到真正的密钥）;
5. 现在，客户端和服务器都知道了这把密钥，就能愉快地用这个密钥对称加密数据...

分析一下上面步骤的可行性：

+ 上述步骤中最终用于加密数据的密钥是客户端生成并且用公钥加密之后传给服务器的，因为私钥只有服务器才有，所以也就只有服务器才能解开客户端上报的密钥；
+ 要保证传输的密钥只能被服务器解密，就得保证用于加密密钥的公钥一定是服务器下发的，绝对不可能被第三方篡改过；

***这里有一种情况***

就是在第二步，服务器把公钥给客户端的时候，如果第三者劫持了真正的公钥，然后传送给客户端一个自己的假的公钥。第三步，客户端用假的公钥加密秘钥后，传送给服务器，但是继续被第三者劫持，第三者用自己的私钥解密数据得到真正的秘钥，然后用服务器的公钥加密秘钥，发送给服务器。

这种情况下，客户端和服务器之间通信的数据就完全被人破解了。

3. 第三层  安全传输秘钥

****

从上一层可以知道，要保证数据的安全，就必须保证客户端接受到的公钥真的是服务器给的，而不是第三者劫持后转给的假的公钥。那怎么保证呢？

**数字证书** 数字证书需要服务器去权威机构申请(需要一定费用)

数字证书包含的内容：
1. 包含一个加密过后的服务器的公钥
2. 权威机构的信息
3. 数字证书的签名(先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)
4. 客户端当前访问的域名

还有一些附加信息...然后服务器只要给客户端下发数字证书就行了。那数字证书中的公钥如何加密呢？

使用的非对称加密，只不过这里是使用只有权威机构自己才有的私钥加密的(这里以权威中心为背书，也就是最大的隐患)。

既然公钥被权威机构的私钥加密了，那客户端收到证书后怎么解密证书中副武器的公钥呢？需要权威机构的公钥才能解密，那这个权威机构的公钥又怎么安全的传输到客户端呢？感觉进入了死循环~~

**答案**

权威机构的公钥不需要传输，因为权威机构会和主流的浏览器或者操作系统合作，将他们的公钥内置在浏览器或操作系统环境中。客户端收到证书之后，只需要从证书中找到权威机构的信息，并从本地环境中找到权威机构的公钥，就能正确解密服务器的公钥。

这样也不是绝对安全的，权威机构既然可以给服务器签发数字证书，也可以给第三者签发数字证书，毕竟赚钱的生意，权威机构也是不拒绝的。

**这样就可能会遇到证书被劫持的问题：**

服务器给客户端下发数字证书时证书被中间人劫持了，中间人将服务器的证书替换成自己的证书下发给客户端，客户端收到之后能够通过权威机构的公钥解密证书内容（因为中间人的证书也是权威机构私钥加密的），从而获取公钥，但是，这里的公钥并不是服务器原本的A公钥，而是中间人自己证书中的B公钥。从第二层可知，如果不能保证客户端收到的公钥是服务器下发的，那整个通信数据的安全就没法保证。简单总结就是证书被调包~

所以，得保证客户端收到的证书就是服务器下发的证书，没有被第三者篡改过。

4. 第四层 安全传输证书

****

两个需求：

+ 证明证书内容没有被第三方篡改过
+ 证明证书是服务器下发的

这些需求其实证书本身已经提供方案了，数字证书中除了包含加密之后的服务器公钥，权威机构的信息外，还包含了证书内容的签名，(先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。这样一来，客户端收到证书之后：

+ 使用权威机构的公钥解密数字证书，得到证书内容（服务器的公钥）以及证书的数字签名，然后根据证书上描述的计算证书签名的方法计算一下当前证书的签名，与收到的签名作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。**所以证书签名就能判断证书是否被篡改**
+ 再考虑证书被掉包的情况：中间人同样可以向权威机构申请一份证书，然后在服务器给客户端下发证书的时候劫持原证书，将自己的假证书下发给客户端，客户端收到之后依然能够使用权威机构的公钥解密证书，并且证书签名也没问题。但是这个时候客户端还需要检查证书中的域名和当前访问的域名是否一致。如果不一致，会发出警告！

[参考1](https://juejin.im/entry/597f2a5a51882556b31f1f1b)
[参考2](https://juejin.im/post/5b0274ac6fb9a07aaa118f49)

以上两篇文章某些细节上有些区别，这里暂不论，大体流程与原理几乎已经清楚。


