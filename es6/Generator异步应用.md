# Generator 函数的异步应用

> 异步编程对 Javascript 语言太重要。JavaScript 语言的执行环境是‘单线程’的，如果没有异步编程，根本没法用，要卡死的。

1. 传统方法

ES6 诞生以前，异步编程的方法大概有一下四种。

- 回调函数
- 事件监听
- 发布、订阅
- Promise 对象

Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。

****

2. 基本概念

所谓‘异步’，就是一个任务不是连续完成的，可以理解成该任务被人分为两个阶段，先是执行第一段，然后转而执行其他任务，等做好了准备，再回头执行第二段。

栗子：有一个任务是读取文件进行处理，第一段是向操作系统发出请求，要求读取文件。然后程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就是异步。

相应的，连续执行的任务就是同步任务。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件这段时间，程序只能干等着。

****

3. 回调函数

JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英文名字 callback，直译过来就是‘重新调用’。

读取文件经行处理，如下：

```
fs.readFile('./etc/passwd', 'utf-8', function(err, data) {
    if(err) throw err;
    console.log(data);
```

上面第三个参数就是回调函数。
+ 一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？

+ 原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。

****

4. Promise 函数

Promise 函数可以避免回调函数陷入回调地狱。这不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。比如读取多个文件，用promise写法如下：

```
var readFile = require('fs-readfile-promise');

readFile(fileA)
.then(function (data) {
  console.log(data.toString());
})
.then(function () {
  return readFile(fileB);
})
.then(function (data) {
  console.log(data.toString());
})
.catch(function (err) {
  console.log(err);
});
```

Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚

****

3. Generator 函数

+ 协程

传统的函数语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中一种叫做‘协程’，意思是多个线程相互协作，完成异步任务。

协程有点像函数，又有点像线程。它的运行流程大致如下。

- 第一步，协程 A 开始执行
- 第二步，协程 A 执行到一半，进入暂停，执行权转移到协程 B
- 第三步，（一段时间后），协程 B 交还执行权
- 第四步，协程 A 恢复执行

上面流程的协程 A，就是异步任务，因为它分成两段（或多段）执行。

**栗子**

```
function* asyncJob(){
  // ...
  let f = yield readFile(fileA);
  // ...
```

上面代码的函数 `asyncJob` 就是一个协程，它的奥妙就在其中的yield命令。他表示执行到此处，执行权将交给其他协程。也就是说，yield 命令是异步两个分界线。

协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点就是代码的写法非常像同步操作，如果去除yield命令，简直就是一模一样。


